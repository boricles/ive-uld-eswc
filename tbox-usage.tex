Given an RDF graph, the summarization is to generate a condensed description which can facilitate data exploitations. In terms of structure, simplest graph patterns are those which only include one node. We can call these patterns as atomic patterns because it is impossible to divide them into smaller structures. By linking atomic patterns, one can construct more complex graph patterns. Following this idea, our summarization method applies a bottom-up strategy to summarize a semantic web dataset. Specifically, we propose an atomic pattern concept in which only one node is involved. Based on this concept, we summarize the given RDF dataset as a new graph which describes the relations between atomic graph patterns.

\subsubsection{Entity Description Block}
A semantic web dataset is essentially an RDF graph. In such a graph, we call its non-literal nodes as entities. For such an entity $e$ in an RDF graph $G$, we can get a data block for it by extracting triples in $G$ each of which has $e$ as its subject or object. We call such kind of data blocks as entity description block. Formally, each entity $e$ has an entity description block (EDB for short) as defined in Definition~\ref{def:edb}.

\begin{definition}
\label{def:edb}
 (Entity Description Block)
$\forall e \in G$, the description block of $e$ is defined as 
\begin{equation}
B_e= \{<e,p_i,o_i>|<e,p_i,o_i> \in G\} \cup \{<s_i,p_i,e>|<s_i,p_i,e> \in G\}
\end{equation}
where $s$ and $p$ are resources in G.
\end{definition}

\subsubsection{Entity Description Pattern}
For an entity description block, its summarisation is introduced as a notion of entity description pattern (Definition~\ref{def:edp}). EDP, the short name for entity description pattern, is the atomic graph pattern in our summarisation model. 

\begin{definition}
\label{def:edp} 
(Entity Description Pattern) Given an entity description block $B_e$, its description pattern is a tuple $P_e=(C_e,A_e,R_e,V_e)$, where
\begin{itemize}
\item $C_e=\{c_i |<e,rdf:type,c_i> \in G\}$   is called as the class component; 
\item $A_e=\{p_i |<e,p_i,l_i> \in G \text{ and $l_i$  is a literal}\}$  is called as the attribute component;
\item $R_e=\{r_i |<e,r_i,o_i> \in G \text{ and $o_i$  is a URI resource or blank node}\}$  is called as the relation component;
\item $V_e=\{v_i |<s_i,v_i,e> \in G\}$ is called as the reverse relation component.
\end{itemize}
\end{definition}

Given the $EDB$ notion, essentially, an RDF graph $G$ is a set of $EDB$ i.e. $G=\cup_{e \in G}{B_e}$. By summarizing all entity description blocks in $G$, we can get the initial summarization result of $G$ i.e. $\cup_{e \in G}{P_e}$ . Given this initial result, we define a merge operation on EDPs which can further condense the summarization. Definition 3 defines the merge operation on EDPs which share the same class component. Based on this definition, we can merge any EDP set by grouping the EDPs in advance. Specifically, before merging, EDPs are grouped into a set of subsets according to their class components i.e. each subset contains a set of EDPs whose class components are identical and EDPs in different subsets have different class components. Then each of these subsets is merged into one EDP according to Definition~\ref{edp:merge}. Finally, all merged EDPs are put together as the merging result.

\begin{definition} 
\label{edp:merge}
(EDP Merge)  Given a set of EDPs:$\{P_i\}_{i=1..n}$ whose elements have identical class component $C$, we can merge these EDPs into a representative EDP as follows:
\begin{equation}
Merge(\{P_i\}_{i=1..n})=(C, \bigcup_{i=1..n}{Attr(P_i)}, \bigcup_{i=1..n}{Rel(P_i)}, \bigcup_{i=1..n}{Rev(P_i)})
\end{equation}
where
\begin{itemize}
\item $Attr(P_i)$ denotes the attribute component of $P_i$;
\item $Rel(P_i)$ denotes the relation component of $P_i$;
\item $Rev(P_i)$ denotes the reverse relation component of $P_i$.
\end{itemize}
\end{definition}

The rationale behind this merge operation is that entities of the same type(s) might be viewed as a set of homogeneous things. This viewpoint is common in knowledge representation e.g. a class is viewed the set of all its individuals. Hence, in terms of graph pattern, the EDPs of all entities sharing the same type(s) should be merged into an integrated pattern.
So far, we can define the EDP function of an RDF graph as Definition~\ref{edp:func}.

\begin{definition} 
\label{edp:func}
(EDP of RDF Graph) Given an RDF graph $G$, its EDP function is defined by the following equation.
\begin{equation}
EDP(G)=Merge(\bigcup_{e \in G}{P_e})
\end{equation}
\end{definition}

\subsubsection{EDP Graph}
EDP is the atomic graph pattern. Generally speaking, interesting queries usually correspond to more complex graph patterns. Hence, it would be more beneficial to know how EDPs are connected to each other in the original RDF graph. To reveal more insights about the RDF dataset in question, we introduce an EDP graph (cf. Definition~\ref{edp:edpgraph}) for characterize the linking structures in the original RDF graph.

\begin{definition} 
\label{edp:edpgraph} (EDP Graph) Given an RDF graph $G$, its EDP graph is defined as follows
\begin{equation}
\begin{split}
\mathcal{G}_{EDP}(G)= & 
\{<P_i,l,P_j>|\exists e_i \in E(P_i ), \exists e_j \in E(P_j ),<e_i,l,e_j> \in G, \\ 
& P_i \in EDP(G),P_j \in EDP(G) \}
\end{split}
\end{equation}
where $E(P_i)$ denotes the set of entities conforms to the EDP $P_i$. If $P_i$ is not merged EDP, $E(P_i)$ is the set of entities from which $P_i$ can be generated; if $P_i$  is a merged one, $E(P_i )=\cup_{P_k \in P}{E(P_k)}$, $P$ is the set of EDPs from which $P_i$  is merged.
\end{definition}

As defined in Definition~\ref{edp:edpgraph}, EDP graph defines the pair-wise link relations between EDPs. From the definition, it can be figured out that if there is a link between entities of a pair of EDPs, they will have a link in the EDP graph. The EDP graph can be used to generate graph patterns or queries. Specifically, a sub-graph of the EDP graph can be converted into a query. It should be noted that if the sub-graph contains more than one links, the generated query might encounter empty result set on the original RDF graph. For example, if in the EDP graph we have $<Student,advisor,FullProfessor>$ and $<FullProfessor,headOf,Department>$, it is possible that in the RDF graph, the department head doesnâ€™t advise any student. However, it can be easily proved that EDP graph has very good properties for supporting efficient data exploitation tasks. Due to limited space, we omit the proofs. Instead different use cases will be demonstrated  as use case studies.
